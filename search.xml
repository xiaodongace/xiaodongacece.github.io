<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识微服务</title>
      <link href="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><br><h3 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h3><p>随着互联网行业的发展,对服务的要求也越来越高,服务架构也从单体架构逐渐演变成为现在流行的微服务架构.</p><h4 id="微服务架构与单体架构之间的区别"><a href="#微服务架构与单体架构之间的区别" class="headerlink" title="微服务架构与单体架构之间的区别"></a>微服务架构与单体架构之间的区别</h4><p><strong>单体架构</strong>: 将业务的所有功能集中在一个项目中开发,打成一个包部署<br><img src="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1.png"></p><p>单体架构的优缺点如下:</p><p><strong>优点</strong>:</p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点</strong>:</p><ul><li>耦合度高(维护困难、升级困难)</li></ul><p><strong>分布式架构</strong>: 根据业务功能对系统做拆分,每个业务功能模块作为独立项目开发,称为一个服务.<br><img src="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2.png"></p><p>分布式的优缺点如下:</p><p><strong>优点</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级的拓展</li></ul><p><strong>缺点</strong></p><ul><li>服务调用关系比较复杂</li></ul><p>分布式架构降低了服务耦合,但是服务拆分也会有很多问题<br>需要思考:</p><ul><li>服务拆分的粒度如何界定</li><li>服务之间如何调用</li><li>服务的调用关系如何管理<br></li></ul><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p><strong>微服务的架构特征</strong>:</p><ul><li><strong>单一职责</strong>: 微服务拆分粒度更小,每一个服务都对应唯一的业务,做到单一职责</li><li><strong>自治</strong>：团队独立、技术独立、数据独立，独立部署和交付</li><li><strong>面向服务</strong>：服务提供统一标准的接口，与语言和技术无关</li><li><strong>隔离性强</strong>：服务调用做好隔离、容错、降级，避免出现级联问题<br><img src="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.png"></li></ul><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。<br><br></p><h3 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2.SpringCloud"></a>2.SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4.png"><br><br></p><p>SpringCloud底层依赖于SpringBoot,并且有版本的兼容关系如下:</p><p><img src="/2022/09/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5.png"><br><br></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><strong>单体架构</strong>：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p><strong>分布式架构</strong>：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p><strong>微服务</strong>：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p><strong>SpringCloud</strong>是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my blog</title>
      <link href="/2022/09/03/my-blog/"/>
      <url>/2022/09/03/my-blog/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 简述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——分库分表</title>
      <link href="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><br><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 </p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1.jpeg"></p><br><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p><img src="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2.jpeg"></p><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><br></p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li>哈希取模: hash(key) % NUM_DB</li><li>范围: 可以是 ID 范围也可以是时间范围</li><li>映射表: 使用单独的一个数据库来存储映射关系<br></li></ul><h3 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h4><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。 </p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h4><ul><li>使用全局唯一 ID: GUID </li><li>为每个分片指定一个 ID 范围 </li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)<br></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——主从复制与读写分离</title>
      <link href="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><br><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程: binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog</strong> 线程 : 负责将主服务器上的数据更改写入二进制日志中。</li><li><strong>I&#x2F;O</strong> 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中日志中。</li><li><strong>SQL</strong> 线程 : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><!-- ![](/MySQL/1.png) --><p><img src="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/1.png"></p><br><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 </p><p>读写分离能提高性能的原因在于: </p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 </p><p><img src="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM——Spring(2)</title>
      <link href="/2022/05/18/Spring2/"/>
      <url>/2022/05/18/Spring2/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><h2 id="一、Spring配置数据源"><a href="#一、Spring配置数据源" class="headerlink" title="一、Spring配置数据源"></a>一、Spring配置数据源</h2><h4 id="1-1-数据源-连接池-的作用"><a href="#1-1-数据源-连接池-的作用" class="headerlink" title="1.1 数据源(连接池)的作用"></a>1.1 数据源(连接池)的作用</h4><ul><li><p>数据源(连接池)是提高程序性能如出现的。</p></li><li><p>事先实例化数据源，初始化部分连接资源。</p></li><li><p>使用连接资源时从数据源中获取。</p></li><li><p>使用完毕后将连接资源归还给数据源。</p></li><li><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等。</p><br></li></ul><h4 id="1-2-数据源的开发步骤"><a href="#1-2-数据源的开发步骤" class="headerlink" title="1.2 数据源的开发步骤"></a>1.2 数据源的开发步骤</h4><ul><li><p>导入数据源的坐标和数据库驱动坐标。</p></li><li><p>创建数据源对象。</p></li><li><p>设置数据源的基本连接数据。</p></li><li><p>使用数据源获取连接资源和归还连接资源。</p></li><li><p>导入c3p0和druid的坐标。<br><img src="/2022/05/18/Spring2/1.jpeg"></p><br></li><li><p>导入MySQL数据库驱动坐标。<br><img src="/2022/05/18/Spring2/2.jpeg"></p><br></li><li><p>创建C3P0连接池。<br><img src="/2022/05/18/Spring2/3.jpeg"></p><br></li><li><p>创建Druid连接池。<br><img src="/2022/05/18/Spring2/4.jpeg"></p><br></li><li><p>提取jdbc.properties配置文件。<br><img src="/2022/05/18/Spring2/5.jpeg"></p><br></li><li><p>读取<strong>jdbc.properties</strong>配置文件创建连接池。<br><img src="/2022/05/18/Spring2/6.jpeg"></p><br></li></ul><h4 id="1-3-Spring配置数据源"><a href="#1-3-Spring配置数据源" class="headerlink" title="1.3 Spring配置数据源"></a>1.3 Spring配置数据源</h4><ul><li><p>可以将DataSource的创建权交由Spring容器去完成。</p><ul><li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的。</li><li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入。<br><img src="/2022/05/18/Spring2/7.jpeg"></li></ul></li><li><p>测试从容器当中获取数据源。<br><img src="/2022/05/18/Spring2/8.jpeg"></p></li></ul><h4 id="1-4-抽取JDBC配置文件"><a href="#1-4-抽取JDBC配置文件" class="headerlink" title="1.4 抽取JDBC配置文件"></a>1.4 抽取JDBC配置文件</h4><ul><li><p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p></li><li><p>首先，需要引入context命名空间和约束路径：</p></li><li><p>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></p></li><li><p>约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context.xsd%E3%80%82">http://www.springframework.org/schema/context/spring-context.xsd。</a><br><img src="/2022/05/18/Spring2/9.jpeg"> </p><br></li></ul><h2 id="二、Spring注解开发"><a href="#二、Spring注解开发" class="headerlink" title="二、Spring注解开发"></a>二、Spring注解开发</h2><ul><li><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p></li><li><p>Spring原始注解主要是替代 <strong>Bean</strong> 的配置。<br><img src="/2022/05/18/Spring2/10.jpeg"> </p><br></li><li><p>使用注解进行开发时，需要在<strong>applicationContext.xml</strong>中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。<br><img src="/2022/05/18/Spring2/11.jpeg"> </p><br></li><li><p>使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。<br><img src="/2022/05/18/Spring2/12.jpeg"> </p><br></li><li><p>使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化，使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入。<br><img src="/2022/05/18/Spring2/13.jpeg"> </p><br></li><li><p>使用@Value进行字符串的注入。<br><img src="/2022/05/18/Spring2/14.jpeg"> </p><br></li><li><p>使用@Scope标注Bean的范围。<br><img src="/2022/05/18/Spring2/15.jpeg"> </p><br></li><li><p>使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法。<br><img src="/2022/05/18/Spring2/16.jpeg"> </p><br></li><li><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下。<br><img src="/2022/05/18/Spring2/17.jpeg"><br><img src="/2022/05/18/Spring2/18.jpeg"> </p><br></li><li><p>@Configuration和@ComponentScan和@Import。<br><img src="/2022/05/18/Spring2/19.jpeg"> </p><br></li><li><p>@PropertySource和@value。<br><img src="/2022/05/18/Spring2/20.jpeg"> </p><br></li><li><p>@Bean。<br><img src="/2022/05/18/Spring2/21.jpeg"> </p><br></li><li><p>测试加载核心配置类创建Spring容器。<br><img src="/2022/05/18/Spring2/22.jpeg"> </p><br></li></ul><h2 id="三、Spring整合Junit"><a href="#三、Spring整合Junit" class="headerlink" title="三、Spring整合Junit"></a>三、Spring整合Junit</h2><h4 id="3-1-原始Junit测试Spring的问题"><a href="#3-1-原始Junit测试Spring的问题" class="headerlink" title="3.1 原始Junit测试Spring的问题"></a>3.1 原始Junit测试Spring的问题</h4><ul><li>在测试类中，每个测试方法都有以下两行代码。这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。<br><img src="/2022/05/18/Spring2/23.jpeg"> <br></li></ul><h4 id="3-2-上述问题解决方法"><a href="#3-2-上述问题解决方法" class="headerlink" title="3.2 上述问题解决方法"></a>3.2 上述问题解决方法</h4><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它。将需要进行测试Bean直接在测试类中进行注入。<br></li></ul><h4 id="3-3-Spring集成Junit步骤"><a href="#3-3-Spring集成Junit步骤" class="headerlink" title="3.3 Spring集成Junit步骤"></a>3.3 Spring集成Junit步骤</h4><p><img src="/2022/05/18/Spring2/24.jpeg"><br><br></p><ul><li><p>导入spring集成Junit的坐标。<br><img src="/2022/05/18/Spring2/25.jpeg"> </p><br></li><li><p>使用@Runwith注解替换原来的运行期。<br><img src="/2022/05/18/Spring2/26.jpeg"> </p><br></li><li><p>使用@ContextConfiguration指定配置文件或配置类。<br><img src="/2022/05/18/Spring2/27.jpeg"> </p><br></li><li><p>使用@Autowired注入需要测试的对象。<br><img src="/2022/05/18/Spring2/28.jpeg"> </p><br></li><li><p>创建测试方法进行测试。<br><img src="/2022/05/18/Spring2/29.jpeg"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM——Spring(1)</title>
      <link href="/2022/05/17/Spring1/"/>
      <url>/2022/05/17/Spring1/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><ul><li><h5 id="Spring是分层的Java-SE-x2F-EE应用轻量级开源框架，以IoC-Inverse-Of-Control：反转控制-和AOP-Aspect-Oriented-Programming：面向切面编程-为内核。"><a href="#Spring是分层的Java-SE-x2F-EE应用轻量级开源框架，以IoC-Inverse-Of-Control：反转控制-和AOP-Aspect-Oriented-Programming：面向切面编程-为内核。" class="headerlink" title="Spring是分层的Java SE&#x2F;EE应用轻量级开源框架，以IoC(Inverse Of Control：反转控制)和AOP(Aspect Oriented Programming：面向切面编程)为内核。"></a>Spring是分层的Java SE&#x2F;EE应用轻量级开源框架，以IoC(Inverse Of Control：反转控制)和AOP(Aspect Oriented Programming：面向切面编程)为内核。</h5></li><li><h5 id="提供了展现层SpringMVC和持久层Spring-JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java-EE企业应用开源框架。"><a href="#提供了展现层SpringMVC和持久层Spring-JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java-EE企业应用开源框架。" class="headerlink" title="提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。"></a>提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</h5></li><li><h5 id="Spring的优势如下。"><a href="#Spring的优势如下。" class="headerlink" title="Spring的优势如下。"></a>Spring的优势如下。</h5><p><img src="/2022/05/17/Spring1/1.png"></p></li><li><p>Spring体系架构如下。<br><img src="/2022/05/17/Spring1/2.png"></p></li></ul><h2 id="二、Spring快速入门"><a href="#二、Spring快速入门" class="headerlink" title="二、Spring快速入门"></a>二、Spring快速入门</h2><p><img src="/2022/05/17/Spring1/3.png"></p><h4 id="Spring程序开发步骤："><a href="#Spring程序开发步骤：" class="headerlink" title="Spring程序开发步骤："></a>Spring程序开发步骤：</h4><ul><li>导入Spring开发的基本包坐标。<ul><li>编写Dao接口和实现类。</li><li>创建Spring核心配置文件。</li><li>在Spring配置文件中配置UserDaoImpl。</li><li>使用Spring的API获得Bean实例。  <br></li></ul></li></ul><h4 id="spring的基本开发坐标"><a href="#spring的基本开发坐标" class="headerlink" title="spring的基本开发坐标"></a>spring的基本开发坐标</h4><p><img src="/2022/05/17/Spring1/4.jpeg"><br><br></p><ul><li>编写Dao接口和实现</li></ul><p><img src="/2022/05/17/Spring1/5.jpeg"><br><br></p><ul><li>创建Spring核心配置文件：在类路径下(resources)创建applicationContext.xml配置文件</li></ul><p><img src="/2022/05/17/Spring1/6.jpeg"><br><br></p><ul><li>在Spring配置文件中配置UserDaoImpl</li></ul><p><img src="/2022/05/17/Spring1/7.jpeg"><br><br></p><ul><li>使用Spring的API获得Bean示例</li></ul><p><img src="/2022/05/17/Spring1/8.jpeg"><br><br></p><h2 id="三、Spring配置文件"><a href="#三、Spring配置文件" class="headerlink" title="三、Spring配置文件"></a>三、Spring配置文件</h2><h4 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h4><ul><li><p>用于配置对象交由Spring来创建。</p></li><li><p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p></li><li><p>基本属性：</p><ul><li><strong>id</strong>：Bean实例在Spring容器中的唯一标识。</li><li><strong>class</strong>：Bean的全限定名称。<br></li></ul></li></ul><h4 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h4><p>scope：指对象的作用范围，取值如下。    </p><p><img src="/2022/05/17/Spring1/9.jpeg"></p><ul><li><p>当scope的取值为<strong>singleton</strong>时：</p><ul><li>Bean的实例化个数：1个。</li><li>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例。</li><li>Bean的生命周期：<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了。</li><li>对象运行：只要容器在，对象一直活着。</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li><p>当scope的取值为<strong>prototype</strong>时：</p><ul><li>Bean的实例化个数：多个。</li><li>Bean的实例化时机：当调用getBean()方法时实例化Bean。<ul><li>对象创建：当使用对象时，创建新的对象实例。</li><li>对象运行：只要对象在使用中，就一直活着。</li><li>对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了。</li></ul></li></ul></li></ul><br><h4 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h4><ul><li><strong>init-method</strong>：指定类中的初始化方法名称。</li><li><strong>destroy-method</strong>：指定类中销毁方法名称。<br></li></ul><h4 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h4><ul><li><p><strong>无参构造</strong>方法实例化。</p></li><li><p><strong>工厂静态</strong>方法实例化。</p></li><li><p><strong>工厂实例</strong>方法实例化 。</p></li><li><p>使用无参构造方法实例化，它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败。</p></li></ul><p><img src="/2022/05/17/Spring1/10.jpeg"><br><br></p><ul><li>工厂静态方法实例化：工厂的静态方法返回Bean实例。</li></ul><p><img src="/2022/05/17/Spring1/12.jpeg"><br><br></p><ul><li>工厂实例方法实例化：工厂的非静态方法返回Bean实例。</li></ul><p><img src="/2022/05/17/Spring1/14.jpeg"><br><br></p><h4 id="3-5-Bean的依赖注入入门"><a href="#3-5-Bean的依赖注入入门" class="headerlink" title="3.5 Bean的依赖注入入门"></a>3.5 Bean的依赖注入入门</h4><ul><li>创建UserServiceImpl，UserServiceImpl内部在调用UserDao的save()方法。</li></ul><p><img src="/2022/05/17/Spring1/15.jpeg"><br><br></p><ul><li>将UserServiceImpl的创建权交给Spring。</li></ul><p><img src="/2022/05/17/Spring1/16.jpeg"><br><br></p><ul><li>从Spring容器中获得UserService进行操作。</li></ul><p><img src="/2022/05/17/Spring1/17.jpeg"><br><br></p><h4 id="3-6-Bean的依赖注入分析"><a href="#3-6-Bean的依赖注入分析" class="headerlink" title="3.6 Bean的依赖注入分析"></a>3.6 Bean的依赖注入分析</h4><ul><li>目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。</li></ul><p><img src="/2022/05/17/Spring1/18.jpeg"><br><br></p><ul><li>因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。</li></ul><p><img src="/2022/05/17/Spring1/19.jpeg"><br><br></p><h4 id="3-7-Bean的依赖注入概念"><a href="#3-7-Bean的依赖注入概念" class="headerlink" title="3.7 Bean的依赖注入概念"></a>3.7 Bean的依赖注入概念</h4><ul><li><p><strong>依赖注入</strong>：<strong>它是Spring框架核心IOC的具体实现</strong>。</p></li><li><p>在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p></li><li><p>那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。</p></li><li><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></li><li><p>Bean的注入依赖方式：</p><ul><li>构造方法。</li><li>set方法。</li></ul></li><li><p>set方法：配置Spring容器调用set方法进行注入。</p></li></ul><p><img src="/2022/05/17/Spring1/20.jpeg"><br><br></p><ul><li>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：首先，需要引入P命名空间，其次，需要修改注入方式。</li></ul><p><img src="/2022/05/17/Spring1/21.jpeg"><br><br></p><ul><li><p>构造方法注入：创建有参构造。</p></li><li><p>配置Spring容器调用有参构造时进行注入。</p></li></ul><p><img src="/2022/05/17/Spring1/22.jpeg"><br><br></p><h4 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h4><ul><li><p>上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p></li><li><p>注入数据的三种数据类型：</p><ul><li>普通数据类型。</li><li>引用数据类型。</li><li>集合数据类型。</li></ul></li><li><p>下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p></li><li><p>普通数据类型的注入。</p></li></ul><p><img src="/2022/05/17/Spring1/23.jpeg"><br><br></p><ul><li>集合数据类型(<strong>List&lt; String &gt;</strong>)的注入。</li></ul><p><img src="/2022/05/17/Spring1/24.jpeg"><br><img src="/2022/05/17/Spring1/25.jpeg"><br><br></p><ul><li>集合数据类型(<strong>List&lt; User &gt;</strong>)的注入。</li></ul><p><img src="/2022/05/17/Spring1/26.jpeg"><br><img src="/2022/05/17/Spring1/27.jpeg"><br><br></p><ul><li>集合数据类型(Properties)的注入。</li></ul><p><img src="/2022/05/17/Spring1/28.jpeg"><br><img src="/2022/05/17/Spring1/29.jpeg"><br><br></p><h4 id="3-9-引入其他配置文件-分模块开发"><a href="#3-9-引入其他配置文件-分模块开发" class="headerlink" title="3.9 引入其他配置文件(分模块开发)"></a>3.9 引入其他配置文件(分模块开发)</h4><ul><li><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载。</p><p>  <img src="/2022/05/17/Spring1/30.jpeg"></p></li></ul><p><img src="/2022/05/17/Spring1/31.jpeg"></p><h2 id="四、Spring相关API"><a href="#四、Spring相关API" class="headerlink" title="四、Spring相关API"></a>四、Spring相关API</h2><h4 id="4-1-ApplicationContext的继承关系"><a href="#4-1-ApplicationContext的继承关系" class="headerlink" title="4.1 ApplicationContext的继承关系"></a>4.1 ApplicationContext的继承关系</h4><ul><li><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring容器中的Bean对象。</p><p>  <img src="/2022/05/17/Spring1/32.jpeg"></p></li></ul><h4 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h4><p><img src="/2022/05/17/Spring1/33.jpeg"> </p><h4 id="4-3-getBean-方法的使用"><a href="#4-3-getBean-方法的使用" class="headerlink" title="4.3 getBean()方法的使用"></a>4.3 getBean()方法的使用</h4><p><img src="/2022/05/17/Spring1/34.jpeg"></p><ul><li>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/04/17/Git/"/>
      <url>/2022/04/17/Git/</url>
      
        <content type="html"><![CDATA[<h4 id="Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub"><a href="#Welcome-to-Xiao-Dong’s-blog-Feel-free-to-view-the-articles-If-you-have-any-questions-feel-free-to-ask-me-on-GitHub" class="headerlink" title="Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub."></a>Welcome to Xiao Dong’s blog! Feel free to view the articles. If you have any questions, feel free to ask me on GitHub.</h4><br><ul><li>文章开始之前先给大家推荐一个很好的在线学习网站<ul><li>推荐给大家: <a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></li></ul></li></ul><p><img src="/2022/04/17/Git/1.png">        </p><h3 id="Git操作流程"><a href="#Git操作流程" class="headerlink" title="Git操作流程"></a>Git操作流程</h3><h4 id="代码提交和同步代码"><a href="#代码提交和同步代码" class="headerlink" title="代码提交和同步代码"></a>代码提交和同步代码</h4><p><img src="/2022/04/17/Git/2.png"><br><br></p><h4 id="代码撤销和撤销同步"><a href="#代码撤销和撤销同步" class="headerlink" title="代码撤销和撤销同步"></a>代码撤销和撤销同步</h4><p><img src="/2022/04/17/Git/3.png"><br><br></p><h3 id="Git常用操作命令-代码提交和同步代码"><a href="#Git常用操作命令-代码提交和同步代码" class="headerlink" title="Git常用操作命令 - 代码提交和同步代码"></a>Git常用操作命令 - 代码提交和同步代码</h3><ul><li>第零步: 工作区与仓库保持一致</li><li>第一步: 文件增删改，变为已修改状态</li><li>第二步: git add ，变为已暂存状态</li></ul><!-- <html><style>    .mac {        width:10px;        height:10px;        border-radius:5px;        float:left;        margin:10px 0 0 5px;    }    .b1 {        background:#E0443E;        margin-left: 10px;    }    .b2 { background:#DEA123; }    .b3 { background:#1AAB29; }    .warpper{        background:#121212;        border-radius:5px 5px 0 0;        width:600px;        height:30px;        color:#0f0;        line-height:30px;    }</style><div class="warpper">    <div class="mac b1"></div>    <div class="mac b2"></div>    <div class="mac b3"></div><div><br></html> --><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add --all <span class="comment"># 当前项目下的所有更改</span></span><br><span class="line">$ git add .  <span class="comment"># 当前目录下的所有更改</span></span><br><span class="line">$ git add xx/xx.py xx/xx2.py  <span class="comment"># 添加某几个文件</span></span><br></pre></td></tr></table></figure><ul><li><p>第三步: git commit，变为已提交状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;&lt;这里写commit的描述&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>第四步: git push，变为已推送状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master <span class="comment"># 第一次需要关联上</span></span><br><span class="line">$ git push <span class="comment"># 之后再推送就不用指明应该推送的远程分支了</span></span><br><span class="line">$ git branch <span class="comment"># 可以查看本地仓库的分支</span></span><br><span class="line">$ git branch -a <span class="comment"># 可以查看本地仓库和本地远程仓库(远程仓库的本地镜像)的所有分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在某个分支下，我最常用的操作如下</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add -a</span><br><span class="line">$ git status</span><br><span class="line">$ git commit -m <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">$ git pull --rebase</span><br><span class="line">$ git push origin xxbranch</span><br></pre></td></tr></table></figure><br><h3 id="Git常用操作命令-代码撤销和撤销同步"><a href="#Git常用操作命令-代码撤销和撤销同步" class="headerlink" title="Git常用操作命令 - 代码撤销和撤销同步"></a>Git常用操作命令 - 代码撤销和撤销同步</h3><p><strong>已修改，但未暂存</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="comment"># 列出所有的修改</span></span><br><span class="line">$ git diff xx/xx.py xx/xx2.py <span class="comment"># 列出某(几)个文件的修改</span></span><br><span class="line"></span><br><span class="line">$ git checkout <span class="comment"># 撤销项目下所有的修改</span></span><br><span class="line">$ git checkout . <span class="comment"># 撤销当前文件夹下所有的修改</span></span><br><span class="line">$ git checkout xx/xx.py xx/xx2.py <span class="comment"># 撤销某几个文件的修改</span></span><br><span class="line">$ git clean -f <span class="comment"># untracked状态，撤销新增的文件</span></span><br><span class="line">$ git clean -<span class="built_in">df</span> <span class="comment"># untracked状态，撤销新增的文件和文件夹</span></span><br></pre></td></tr></table></figure><br><p><strong>已暂存，未提交</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached <span class="comment"># 这个命令显示暂存区和本地仓库的差异</span></span><br><span class="line"></span><br><span class="line">$ git reset <span class="comment"># 暂存区的修改恢复到工作区</span></span><br><span class="line">$ git reset --soft <span class="comment"># 与git reset等价，回到已修改状态，修改的内容仍然在工作区中</span></span><br><span class="line">$ git reset --hard <span class="comment"># 回到未修改状态，清空暂存区和工作区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>git reset –hard 操作等价于 git reset 和 git checkout 2步操作</p></blockquote><br><p><strong>已提交，未推送</strong></p><blockquote><p>执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值回退到这次提交。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;branch-name1&gt; &lt;branch-name2&gt; <span class="comment"># 比较2个分支之间的差异</span></span><br><span class="line">$ git diff master origin/master <span class="comment"># 查看本地仓库与本地远程仓库的差异</span></span><br><span class="line"></span><br><span class="line">$ git reset --hard origin/master <span class="comment"># 回退与本地远程仓库一致</span></span><br><span class="line">$ git reset --hard HEAD^ <span class="comment"># 回退到本地仓库上一个版本</span></span><br><span class="line">$ git reset --hard &lt;<span class="built_in">hash</span> code&gt; <span class="comment"># 回退到任意版本</span></span><br><span class="line">$ git reset --soft/git reset <span class="comment"># 回退且回到已修改状态，修改仍保留在工作区中。</span></span><br></pre></td></tr></table></figure><br><p><strong>已推送到远程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f orgin master # 强制覆盖远程分支</span><br><span class="line">$ git push -f # 如果之前已经用 -u 关联过，则可省略分支名</span><br></pre></td></tr></table></figure><blockquote><p>慎用，一般情况下，本地分支比远程要新，所以可以直接推送到远程，但有时推送到远程后发现有问题，进行了版本回退，旧版本或者分叉版本推送到远程，需要添加 -f参数，表示强制覆盖。</p></blockquote><br><h3 id="Git常用操作命令-其它常用命令"><a href="#Git常用操作命令-其它常用命令" class="headerlink" title="Git常用操作命令 - 其它常用命令"></a>Git常用操作命令 - 其它常用命令</h3><p><strong>关联远程仓库</strong></p><ul><li><p>如果还没有Git仓库，你需要</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>如果你想关联远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;name&gt; &lt;git-repo-url&gt;</span><br><span class="line"><span class="comment"># 例如 git remote add origin https://github.com/xxxxxx # 是远程仓库的名称，通常为 origin</span></span><br></pre></td></tr></table></figure></li><li><p>如果你想关联多个远程仓库 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;name&gt; &lt;another-git-repo-url&gt;</span><br><span class="line"><span class="comment"># 例如 git remote add coding https://coding.net/xxxxxx</span></span><br></pre></td></tr></table></figure></li><li><p>忘了关联了哪些仓库或者地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># origin https://github.com/gzdaijie/koa-react-server-render-blog.git (fetch)</span></span><br><span class="line"><span class="comment"># origin https://github.com/gzdaijie/koa-react-server-render-blog.git (push)</span></span><br></pre></td></tr></table></figure></li><li><p>如果远程有仓库，你需要clone到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;git-repo-url&gt;</span><br><span class="line"><span class="comment"># 关联的远程仓库将被命名为origin，这是默认的。</span></span><br></pre></td></tr></table></figure></li><li><p>如果你想把别人仓库的地址改为自己的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin &lt;your-git-url&gt;</span><br></pre></td></tr></table></figure><br></li></ul><p><strong>切换分支</strong></p><blockquote><p>新建仓库后，默认生成了master分支</p></blockquote><ul><li><p>如果你想新建分支并切换</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"><span class="comment"># 例如 git checkout -b dev</span></span><br><span class="line"><span class="comment"># 如果仅新建，不切换，则去掉参数 -b</span></span><br></pre></td></tr></table></figure></li><li><p>看看当前有哪些分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"><span class="comment"># * dev</span></span><br><span class="line"><span class="comment">#   master # 标*号的代表当前所在的分支</span></span><br></pre></td></tr></table></figure></li><li><p>看看当前本地&amp;远程有哪些分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line"><span class="comment"># * dev</span></span><br><span class="line"><span class="comment">#   master</span></span><br><span class="line"><span class="comment">#   remotes/origin/master</span></span><br></pre></td></tr></table></figure></li><li><p>切换到现有的分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>你想把dev分支合并到master分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch-name&gt;</span><br><span class="line"><span class="comment"># 例如 git merge dev</span></span><br></pre></td></tr></table></figure></li><li><p>你想把本地master分支推送到远程去</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"><span class="comment"># 你可以使用git push -u origin master将本地分支与远程分支关联，之后仅需要使用git push即可。</span></span><br></pre></td></tr></table></figure></li><li><p>远程分支被别人更新了，你需要更新代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin &lt;branch-name&gt;</span><br><span class="line"><span class="comment"># 之前如果push时使用过-u，那么就可以省略为git pull</span></span><br></pre></td></tr></table></figure></li><li><p>本地有修改，能不能先git pull</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="comment"># 工作区修改暂存</span></span><br><span class="line">$ git pull  <span class="comment"># 更新分支</span></span><br><span class="line">$ git stash pop <span class="comment"># 暂存修改恢复到工作区</span></span><br></pre></td></tr></table></figure><br></li></ul><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul><li><p>恢复暂存区文件到工作区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>恢复暂存区的所有文件到工作区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout .</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区的某文件，与上一次commit保持一致，但工作区不变</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区与工作区，与上一次commit保持一致</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;file-name&gt;</span><br><span class="line"><span class="comment"># 如果是回退版本(commit)，那么file，变成commit的hash码就好了。</span></span><br></pre></td></tr></table></figure></li><li><p>去掉某个commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-hash&gt;</span><br><span class="line"><span class="comment"># 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果</span></span><br></pre></td></tr></table></figure></li><li><p>reset回退错误恢复</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog <span class="comment">#查看最近操作记录</span></span><br><span class="line">$ git reset --hard HEAD&#123;5&#125; <span class="comment">#恢复到前五笔操作</span></span><br><span class="line">$ git pull origin backend-log <span class="comment">#再次拉取代码</span></span><br></pre></td></tr></table></figure><br></li></ul><h3 id="版本回退与前进"><a href="#版本回退与前进" class="headerlink" title="版本回退与前进"></a>版本回退与前进</h3><ul><li><p>查看历史版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li><li><p>你可能觉得这样的log不好看，试试这个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --decorate --abbrev-commit --all</span><br></pre></td></tr></table></figure></li><li><p>检出到任意版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout a5d88ea</span><br><span class="line"><span class="comment"># hash码很长，通常6-7位就够了</span></span><br></pre></td></tr></table></figure></li><li><p>远程仓库的版本很新，但是你还是想用老版本覆盖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master --force</span><br><span class="line"><span class="comment"># 或者 git push -f origin master</span></span><br></pre></td></tr></table></figure></li><li><p>觉得commit太多了? 多个commit合并为1个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~4</span><br><span class="line"><span class="comment"># 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。将进入VIM界面，你可以修改提交信息。推送到远程分支的commit，不建议这样做，多人合作时，通常不建议修改历史。</span></span><br></pre></td></tr></table></figure></li><li><p>想回退到某一个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line"><span class="comment"># 例如 git reset --hard a3hd73r</span></span><br><span class="line"><span class="comment"># --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，--soft参数代表保留工作区的修改。</span></span><br></pre></td></tr></table></figure></li><li><p>想回退到上一个版本，有没有简便方法?</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>回退到上上个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^^</span><br><span class="line"><span class="comment"># HEAD^^可以换作具体版本hash值。</span></span><br></pre></td></tr></table></figure></li><li><p>回退错了，能不能前进</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line"><span class="comment"># 这个命令保留了最近执行的操作及所处的版本，每条命令前的hash值，则是对应版本的hash值。使用上述的git checkout 或者 git reset命令 则可以检出或回退到对应版本。</span></span><br></pre></td></tr></table></figure></li><li><p>刚才commit信息写错了，可以修改吗</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>看看当前状态吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="配置属于你的Git"><a href="#配置属于你的Git" class="headerlink" title="配置属于你的Git"></a>配置属于你的Git</h3><ul><li><p>看看当前的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></li><li><p>估计你需要配置你的名字</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;&lt;name&gt;&quot;</span></span><br><span class="line"><span class="comment">#  --global为可选参数，该参数表示配置全局信息</span></span><br></pre></td></tr></table></figure></li><li><p>希望别人看到你的commit可以联系到你</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;&lt;email address&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>有些命令很长，能不能简化一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.logg <span class="string">&quot;log --graph --decorate --abbrev-commit --all&quot;</span></span><br><span class="line"><span class="comment"># 之后就可以开心地使用 git log了</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
