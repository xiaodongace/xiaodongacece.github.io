<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="/2022/09/08/Docker/"/>
      <url>/2022/09/08/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p><ul><li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li><li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题<br></li></ul><h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p><ul><li><p>依赖关系复杂，容易出现兼容性问题</p></li><li><p>开发、测试、生产环境有差异</p></li></ul><p><img src="/2022/09/08/Docker/1.jpeg" alt="1"></p><p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。<br><br></p><h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p><p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p><ul><li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p></li><li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p></li></ul><p><img src="/2022/09/08/Docker/2.png"></p><p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p><p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？<br><br></p><h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p><p><img src="/2022/09/08/Docker/3.png"></p><p>结构包括：</p><ul><li>计算机硬件：例如CPU、内存、磁盘等</li><li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li><li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li></ul><p>应用于计算机交互的流程如下：</p><p>1）应用调用操作系统应用（函数库），实现各种功能</p><p>2）系统函数库是对内核指令集的封装，会调用内核指令</p><p>3）内核指令操作计算机硬件</p><p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p><p><img src="/2022/09/08/Docker/4.png"></p><p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p><p><img src="/2022/09/08/Docker/5.png"></p><p>Docker如何解决不同系统环境的问题？</p><ul><li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li><li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li></ul><p>如图：</p><p><img src="/2022/09/08/Docker/6.png"><br><br></p><h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p><ul><li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li><li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li></ul><p>Docker如何解决开发、测试、生产环境有差异的问题？</p><ul><li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li></ul><p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p><ul><li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li><li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li><li>启动、移除都可以通过一行命令完成，方便快捷<br></li></ul><h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p><p>两者有什么差异呢？</p><p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p><p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p><p><img src="/2022/09/08/Docker/7.png"></p><p>对比来看：</p><p><img src="/2022/09/08/Docker/8.png"></p><p>小结：</p><p>Docker和虚拟机的差异：</p><ul><li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p></li><li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p><br></li></ul><h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p><p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p><p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p><p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p><p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p><p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p><p><img src="/2022/09/08/Docker/9.png"></p><p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。<br><br></p><h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p><ul><li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p></li><li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p></li></ul><p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p><p><img src="/2022/09/08/Docker/10.png"></p><br><h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p><p>Docker是一个CS架构的程序，由两部分组成：</p><ul><li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p></li><li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p></li></ul><p>如图：</p><p><img src="/2022/09/08/Docker/11.png"><br><br></p><h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p><ul><li>将应用程序及其依赖、环境、配置打包在一起</li></ul><p>容器：</p><ul><li>镜像运行起来就是容器，一个镜像可以运行多个容器</li></ul><p>Docker结构：</p><ul><li><p>服务端：接收命令或远程请求，操作镜像或容器</p></li><li><p>客户端：发送命令或者请求到Docker服务端</p></li></ul><p>DockerHub：</p><ul><li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry<br></li></ul><h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定tag时，默认是latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="/2022/09/08/Docker/12.png"></p><p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。<br><br></p><h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="/2022/09/08/Docker/13.png"></p><br><h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p><p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p><p><img src="/2022/09/08/Docker/14.png"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="/2022/09/08/Docker/15.png"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="/2022/09/08/Docker/16.png"><br><br></p><h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p><p>1）利用docker xx –help命令查看docker save和docker load的语法</p><p>例如，查看save命令用法，可以输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/08/Docker/17.jpeg"></p><p>命令格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure><p>2）使用docker save导出镜像到磁盘 </p><p>运行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/2022/09/08/Docker/18.jpeg"></p><p>3）使用docker load加载镜像</p><p>先删除本地的nginx镜像：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure><p>然后运行命令，加载本地文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/08/Docker/19.jpeg"><br><br></p><h3 id="2-1-5-这里做一个简单的小练习-大家感兴趣可以尝试一下"><a href="#2-1-5-这里做一个简单的小练习-大家感兴趣可以尝试一下" class="headerlink" title="2.1.5.这里做一个简单的小练习,大家感兴趣可以尝试一下"></a>2.1.5.这里做一个简单的小练习,大家感兴趣可以尝试一下</h3><p>需求：去DockerHub搜索并拉取一个Redis镜像</p><p>目标：</p><p>1）去DockerHub搜索Redis镜像</p><p>2）查看Redis镜像的名称和版本</p><p>3）利用docker pull命令拉取镜像</p><p>4）利用docker save命令将 redis:latest打包为一个redis.tar包</p><p>5）利用docker rmi 删除本地的redis:latest</p><p>6）利用docker load 重新加载 redis.tar文件<br><br></p><h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="/2022/09/08/Docker/40.png"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU等资源</li></ul><p>其中：</p><ul><li><strong>docker run</strong>：创建并运行一个容器，处于运行状态</li><li><strong>docker pause</strong>：让一个运行的容器暂停</li><li><strong>docker unpause</strong>：让一个容器从暂停状态恢复运行</li><li><strong>docker stop</strong>：停止一个运行的容器</li><li><strong>docker start</strong>：让一个停止的容器再次运行</li><li><strong>docker rm</strong>：删除一个容器<br></li></ul><h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>–name : 给容器起一个名字，比如叫做mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p><p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p><p><img src="/2022/09/08/Docker/41.png"><br><br></p><h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“我们是最棒的”</p><p><strong>提示</strong>：进入容器要用到docker exec命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p></li></ul><p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p><p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p><p><img src="/2022/09/08/Docker/20.jpg"></p><p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p><p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure><p> 查看目录下文件：</p><p><img src="/2022/09/08/Docker/21.jpg"><br><br></p><p>3）修改index.html的内容</p><p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#我们是最棒的#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure><br><p>在浏览器访问自己的虚拟机地址即可看到结果:</p><p><img src="/2022/09/08/Docker/22.jpg"><br><br></p><h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p><ul><li>–name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><br><h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="/2022/09/08/Docker/42.png"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷</strong>（<strong>volume</strong>)是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="/2022/09/08/Docker/43.png"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p><br><h3 id="2-3-2-数据卷操作命令"><a href="#2-3-2-数据卷操作命令" class="headerlink" title="2.3.2.数据卷操作命令"></a>2.3.2.数据卷操作命令</h3><p>数据卷操作的基本语法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure><p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p><ul><li><strong>create:</strong> 创建一个volume</li><li><strong>inspect:</strong> 显示一个或多个volume的信息</li><li><strong>ls:</strong> 列出所有的volume</li><li><strong>prune:</strong> 删除未使用的volume</li><li><strong>rm:</strong> 删除一个或多个指定的volume</li></ul><br><h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure><p>② 查看所有数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/08/Docker/23.jpg"></p><p>③ 查看数据卷详细信息卷</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2022/09/08/Docker/23.jpg"></p><p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><br><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><br><h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure><p>这里的-v就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li></ul><br><h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p><p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的HTML目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><p>② 进入html数据卷所在位置，并修改HTML内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure><br><h3 id="2-3-6-挂载本地目录"><a href="#2-3-6-挂载本地目录" class="headerlink" title="2.3.6.挂载本地目录"></a>2.3.6.挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li></ul><p>如图：</p><p><img src="/2022/09/08/Docker/44.png"></p><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><br><h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul><br><h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p><p>而要自定义镜像，就必须先了解镜像的结构才行。</p><h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p><p>我们以MySQL为例，来看看镜像的组成结构：</p><p><img src="/2022/09/08/Docker/45.png"></p><p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p><p>我们要构建镜像，其实就是实现上述打包的过程。<br><br></p><h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p><p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p><p>而描述上述信息的文件就是Dockerfile文件。</p><p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p><p><img src="/2022/09/08/Docker/46.png"></p><p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识微服务</title>
      <link href="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<br><h3 id="1-认识微服务"><a href="#1-认识微服务" class="headerlink" title="1.认识微服务"></a>1.认识微服务</h3><p>随着互联网行业的发展,对服务的要求也越来越高,服务架构也从单体架构逐渐演变成为现在流行的微服务架构.</p><h4 id="微服务架构与单体架构之间的区别"><a href="#微服务架构与单体架构之间的区别" class="headerlink" title="微服务架构与单体架构之间的区别"></a>微服务架构与单体架构之间的区别</h4><p><strong>单体架构</strong>: 将业务的所有功能集中在一个项目中开发,打成一个包部署<br><img src="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1.png"></p><p>单体架构的优缺点如下:</p><p><strong>优点</strong>:</p><ul><li>架构简单</li><li>部署成本低</li></ul><p><strong>缺点</strong>:</p><ul><li>耦合度高(维护困难、升级困难)</li></ul><p><strong>分布式架构</strong>: 根据业务功能对系统做拆分,每个业务功能模块作为独立项目开发,称为一个服务.<br><img src="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2.png"></p><p>分布式的优缺点如下:</p><p><strong>优点</strong></p><ul><li>降低服务耦合</li><li>有利于服务升级的拓展</li></ul><p><strong>缺点</strong></p><ul><li>服务调用关系比较复杂</li></ul><p>分布式架构降低了服务耦合,但是服务拆分也会有很多问题<br>需要思考:</p><ul><li>服务拆分的粒度如何界定</li><li>服务之间如何调用</li><li>服务的调用关系如何管理<br></li></ul><h4 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h4><p><strong>微服务的架构特征</strong>:</p><ul><li><strong>单一职责</strong>: 微服务拆分粒度更小,每一个服务都对应唯一的业务,做到单一职责</li><li><strong>自治</strong>：团队独立、技术独立、数据独立，独立部署和交付</li><li><strong>面向服务</strong>：服务提供统一标准的接口，与语言和技术无关</li><li><strong>隔离性强</strong>：服务调用做好隔离、容错、降级，避免出现级联问题<br><img src="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3.png"></li></ul><p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p><p>因此，可以认为<strong>微服务</strong>是一种经过良好架构设计的<strong>分布式架构方案</strong> 。</p><p>其中在Java领域最引人注目的就是SpringCloud提供的方案了。<br><br></p><h3 id="2-SpringCloud"><a href="#2-SpringCloud" class="headerlink" title="2.SpringCloud"></a>2.SpringCloud</h3><p>SpringCloud是目前国内使用最广泛的微服务框架。官网地址：<a href="https://spring.io/projects/spring-cloud%E3%80%82">https://spring.io/projects/spring-cloud。</a></p><p>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p><p>其中常见的组件包括：</p><p><img src="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4.png"><br><br></p><p>SpringCloud底层依赖于SpringBoot,并且有版本的兼容关系如下:</p><p><img src="/2022/09/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5.png"><br><br></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p><strong>单体架构</strong>：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</p></li><li><p><strong>分布式架构</strong>：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</p></li><li><p><strong>微服务</strong>：一种良好的分布式架构方案</p><p>①优点：拆分粒度更小、服务更独立、耦合度更低</p><p>②缺点：架构非常复杂，运维、监控、部署难度提高</p></li><li><p><strong>SpringCloud</strong>是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——分库分表</title>
      <link href="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
      <url>/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<br><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 </p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><p><img src="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1.jpeg"></p><br><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p><img src="/2022/08/10/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2.jpeg"></p><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。<br><br></p><h3 id="Sharding-策略"><a href="#Sharding-策略" class="headerlink" title="Sharding 策略"></a>Sharding 策略</h3><ul><li>哈希取模: hash(key) % NUM_DB</li><li>范围: 可以是 ID 范围也可以是时间范围</li><li>映射表: 使用单独的一个数据库来存储映射关系<br></li></ul><h3 id="Sharding-存在的问题及解决方案"><a href="#Sharding-存在的问题及解决方案" class="headerlink" title="Sharding 存在的问题及解决方案"></a>Sharding 存在的问题及解决方案</h3><h4 id="1-事务问题"><a href="#1-事务问题" class="headerlink" title="1. 事务问题"></a>1. 事务问题</h4><p>使用分布式事务来解决，比如 XA 接口。</p><h4 id="2-链接"><a href="#2-链接" class="headerlink" title="2. 链接"></a>2. 链接</h4><p>可以将原来的 JOIN 分解成多个单表查询，然后在用户程序中进行 JOIN。 </p><h4 id="3-ID-唯一性"><a href="#3-ID-唯一性" class="headerlink" title="3. ID 唯一性"></a>3. ID 唯一性</h4><ul><li>使用全局唯一 ID: GUID </li><li>为每个分片指定一个 ID 范围 </li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)<br></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL——主从复制与读写分离</title>
      <link href="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<br><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主要涉及三个线程: binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog</strong> 线程 : 负责将主服务器上的数据更改写入二进制日志中。</li><li><strong>I&#x2F;O</strong> 线程 : 负责从主服务器上读取二进制日志，并写入从服务器的中日志中。</li><li><strong>SQL</strong> 线程 : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><!-- ![](/MySQL/1.png) --><p><img src="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/1.png"></p><br><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 </p><p>读写分离能提高性能的原因在于: </p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 </p><p><img src="/2022/08/08/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/2.png"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM——Spring(2)</title>
      <link href="/2022/05/18/Spring2/"/>
      <url>/2022/05/18/Spring2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring配置数据源"><a href="#一、Spring配置数据源" class="headerlink" title="一、Spring配置数据源"></a>一、Spring配置数据源</h2><h4 id="1-1-数据源-连接池-的作用"><a href="#1-1-数据源-连接池-的作用" class="headerlink" title="1.1 数据源(连接池)的作用"></a>1.1 数据源(连接池)的作用</h4><ul><li><p>数据源(连接池)是提高程序性能如出现的。</p></li><li><p>事先实例化数据源，初始化部分连接资源。</p></li><li><p>使用连接资源时从数据源中获取。</p></li><li><p>使用完毕后将连接资源归还给数据源。</p></li><li><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等。</p><br></li></ul><h4 id="1-2-数据源的开发步骤"><a href="#1-2-数据源的开发步骤" class="headerlink" title="1.2 数据源的开发步骤"></a>1.2 数据源的开发步骤</h4><ul><li><p>导入数据源的坐标和数据库驱动坐标。</p></li><li><p>创建数据源对象。</p></li><li><p>设置数据源的基本连接数据。</p></li><li><p>使用数据源获取连接资源和归还连接资源。</p></li><li><p>导入c3p0和druid的坐标。<br><img src="/2022/05/18/Spring2/1.jpeg"></p><br></li><li><p>导入MySQL数据库驱动坐标。<br><img src="/2022/05/18/Spring2/2.jpeg"></p><br></li><li><p>创建C3P0连接池。<br><img src="/2022/05/18/Spring2/3.jpeg"></p><br></li><li><p>创建Druid连接池。<br><img src="/2022/05/18/Spring2/4.jpeg"></p><br></li><li><p>提取jdbc.properties配置文件。<br><img src="/2022/05/18/Spring2/5.jpeg"></p><br></li><li><p>读取<strong>jdbc.properties</strong>配置文件创建连接池。<br><img src="/2022/05/18/Spring2/6.jpeg"></p><br></li></ul><h4 id="1-3-Spring配置数据源"><a href="#1-3-Spring配置数据源" class="headerlink" title="1.3 Spring配置数据源"></a>1.3 Spring配置数据源</h4><ul><li><p>可以将DataSource的创建权交由Spring容器去完成。</p><ul><li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的。</li><li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入。<br><img src="/2022/05/18/Spring2/7.jpeg"></li></ul></li><li><p>测试从容器当中获取数据源。<br><img src="/2022/05/18/Spring2/8.jpeg"></p></li></ul><h4 id="1-4-抽取JDBC配置文件"><a href="#1-4-抽取JDBC配置文件" class="headerlink" title="1.4 抽取JDBC配置文件"></a>1.4 抽取JDBC配置文件</h4><ul><li><p>applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p></li><li><p>首先，需要引入context命名空间和约束路径：</p></li><li><p>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a></p></li><li><p>约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context.xsd%E3%80%82">http://www.springframework.org/schema/context/spring-context.xsd。</a><br><img src="/2022/05/18/Spring2/9.jpeg"> </p><br></li></ul><h2 id="二、Spring注解开发"><a href="#二、Spring注解开发" class="headerlink" title="二、Spring注解开发"></a>二、Spring注解开发</h2><ul><li><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p></li><li><p>Spring原始注解主要是替代 <strong>Bean</strong> 的配置。<br><img src="/2022/05/18/Spring2/10.jpeg"> </p><br></li><li><p>使用注解进行开发时，需要在<strong>applicationContext.xml</strong>中配置组件扫描，作用是指定哪个包及其子包下的Bean需要进行扫描以便识别使用注解配置的类、字段和方法。<br><img src="/2022/05/18/Spring2/11.jpeg"> </p><br></li><li><p>使用@Compont或@Repository标识UserDaoImpl需要Spring进行实例化。<br><img src="/2022/05/18/Spring2/12.jpeg"> </p><br></li><li><p>使用@Compont或@Service标识UserServiceImpl需要Spring进行实例化，使用@Autowired或者@Autowired+@Qulifier或者@Resource进行userDao的注入。<br><img src="/2022/05/18/Spring2/13.jpeg"> </p><br></li><li><p>使用@Value进行字符串的注入。<br><img src="/2022/05/18/Spring2/14.jpeg"> </p><br></li><li><p>使用@Scope标注Bean的范围。<br><img src="/2022/05/18/Spring2/15.jpeg"> </p><br></li><li><p>使用@PostConstruct标注初始化方法，使用@PreDestroy标注销毁方法。<br><img src="/2022/05/18/Spring2/16.jpeg"> </p><br></li><li><p>使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下。<br><img src="/2022/05/18/Spring2/17.jpeg"><br><img src="/2022/05/18/Spring2/18.jpeg"> </p><br></li><li><p>@Configuration和@ComponentScan和@Import。<br><img src="/2022/05/18/Spring2/19.jpeg"> </p><br></li><li><p>@PropertySource和@value。<br><img src="/2022/05/18/Spring2/20.jpeg"> </p><br></li><li><p>@Bean。<br><img src="/2022/05/18/Spring2/21.jpeg"> </p><br></li><li><p>测试加载核心配置类创建Spring容器。<br><img src="/2022/05/18/Spring2/22.jpeg"> </p><br></li></ul><h2 id="三、Spring整合Junit"><a href="#三、Spring整合Junit" class="headerlink" title="三、Spring整合Junit"></a>三、Spring整合Junit</h2><h4 id="3-1-原始Junit测试Spring的问题"><a href="#3-1-原始Junit测试Spring的问题" class="headerlink" title="3.1 原始Junit测试Spring的问题"></a>3.1 原始Junit测试Spring的问题</h4><ul><li>在测试类中，每个测试方法都有以下两行代码。这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。<br><img src="/2022/05/18/Spring2/23.jpeg"> <br></li></ul><h4 id="3-2-上述问题解决方法"><a href="#3-2-上述问题解决方法" class="headerlink" title="3.2 上述问题解决方法"></a>3.2 上述问题解决方法</h4><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它。将需要进行测试Bean直接在测试类中进行注入。<br></li></ul><h4 id="3-3-Spring集成Junit步骤"><a href="#3-3-Spring集成Junit步骤" class="headerlink" title="3.3 Spring集成Junit步骤"></a>3.3 Spring集成Junit步骤</h4><p><img src="/2022/05/18/Spring2/24.jpeg"><br><br></p><ul><li><p>导入spring集成Junit的坐标。<br><img src="/2022/05/18/Spring2/25.jpeg"> </p><br></li><li><p>使用@Runwith注解替换原来的运行期。<br><img src="/2022/05/18/Spring2/26.jpeg"> </p><br></li><li><p>使用@ContextConfiguration指定配置文件或配置类。<br><img src="/2022/05/18/Spring2/27.jpeg"> </p><br></li><li><p>使用@Autowired注入需要测试的对象。<br><img src="/2022/05/18/Spring2/28.jpeg"> </p><br></li><li><p>创建测试方法进行测试。<br><img src="/2022/05/18/Spring2/29.jpeg"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM——Spring(1)</title>
      <link href="/2022/05/17/Spring1/"/>
      <url>/2022/05/17/Spring1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Spring简介"><a href="#一、Spring简介" class="headerlink" title="一、Spring简介"></a>一、Spring简介</h2><ul><li><h5 id="Spring是分层的Java-SE-x2F-EE应用轻量级开源框架，以IoC-Inverse-Of-Control：反转控制-和AOP-Aspect-Oriented-Programming：面向切面编程-为内核。"><a href="#Spring是分层的Java-SE-x2F-EE应用轻量级开源框架，以IoC-Inverse-Of-Control：反转控制-和AOP-Aspect-Oriented-Programming：面向切面编程-为内核。" class="headerlink" title="Spring是分层的Java SE&#x2F;EE应用轻量级开源框架，以IoC(Inverse Of Control：反转控制)和AOP(Aspect Oriented Programming：面向切面编程)为内核。"></a>Spring是分层的Java SE&#x2F;EE应用轻量级开源框架，以IoC(Inverse Of Control：反转控制)和AOP(Aspect Oriented Programming：面向切面编程)为内核。</h5></li><li><h5 id="提供了展现层SpringMVC和持久层Spring-JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java-EE企业应用开源框架。"><a href="#提供了展现层SpringMVC和持久层Spring-JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java-EE企业应用开源框架。" class="headerlink" title="提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。"></a>提供了展现层SpringMVC和持久层Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE企业应用开源框架。</h5></li><li><h5 id="Spring的优势如下。"><a href="#Spring的优势如下。" class="headerlink" title="Spring的优势如下。"></a>Spring的优势如下。</h5><p><img src="/2022/05/17/Spring1/1.png"></p></li><li><p>Spring体系架构如下。<br><img src="/2022/05/17/Spring1/2.png"></p></li></ul><h2 id="二、Spring快速入门"><a href="#二、Spring快速入门" class="headerlink" title="二、Spring快速入门"></a>二、Spring快速入门</h2><p><img src="/2022/05/17/Spring1/3.png"></p><h4 id="Spring程序开发步骤："><a href="#Spring程序开发步骤：" class="headerlink" title="Spring程序开发步骤："></a>Spring程序开发步骤：</h4><ul><li>导入Spring开发的基本包坐标。<ul><li>编写Dao接口和实现类。</li><li>创建Spring核心配置文件。</li><li>在Spring配置文件中配置UserDaoImpl。</li><li>使用Spring的API获得Bean实例。  <br></li></ul></li></ul><h4 id="spring的基本开发坐标"><a href="#spring的基本开发坐标" class="headerlink" title="spring的基本开发坐标"></a>spring的基本开发坐标</h4><p><img src="/2022/05/17/Spring1/4.jpeg"><br><br></p><ul><li>编写Dao接口和实现</li></ul><p><img src="/2022/05/17/Spring1/5.jpeg"><br><br></p><ul><li>创建Spring核心配置文件：在类路径下(resources)创建applicationContext.xml配置文件</li></ul><p><img src="/2022/05/17/Spring1/6.jpeg"><br><br></p><ul><li>在Spring配置文件中配置UserDaoImpl</li></ul><p><img src="/2022/05/17/Spring1/7.jpeg"><br><br></p><ul><li>使用Spring的API获得Bean示例</li></ul><p><img src="/2022/05/17/Spring1/8.jpeg"><br><br></p><h2 id="三、Spring配置文件"><a href="#三、Spring配置文件" class="headerlink" title="三、Spring配置文件"></a>三、Spring配置文件</h2><h4 id="3-1-Bean标签基本配置"><a href="#3-1-Bean标签基本配置" class="headerlink" title="3.1 Bean标签基本配置"></a>3.1 Bean标签基本配置</h4><ul><li><p>用于配置对象交由Spring来创建。</p></li><li><p>默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。</p></li><li><p>基本属性：</p><ul><li><strong>id</strong>：Bean实例在Spring容器中的唯一标识。</li><li><strong>class</strong>：Bean的全限定名称。<br></li></ul></li></ul><h4 id="3-2-Bean标签范围配置"><a href="#3-2-Bean标签范围配置" class="headerlink" title="3.2 Bean标签范围配置"></a>3.2 Bean标签范围配置</h4><p>scope：指对象的作用范围，取值如下。    </p><p><img src="/2022/05/17/Spring1/9.jpeg"></p><ul><li><p>当scope的取值为<strong>singleton</strong>时：</p><ul><li>Bean的实例化个数：1个。</li><li>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例。</li><li>Bean的生命周期：<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了。</li><li>对象运行：只要容器在，对象一直活着。</li><li>对象销毁：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li><p>当scope的取值为<strong>prototype</strong>时：</p><ul><li>Bean的实例化个数：多个。</li><li>Bean的实例化时机：当调用getBean()方法时实例化Bean。<ul><li>对象创建：当使用对象时，创建新的对象实例。</li><li>对象运行：只要对象在使用中，就一直活着。</li><li>对象销毁：当对象长时间不用时，被Java的垃圾回收器回收了。</li></ul></li></ul></li></ul><br><h4 id="3-3-Bean生命周期配置"><a href="#3-3-Bean生命周期配置" class="headerlink" title="3.3 Bean生命周期配置"></a>3.3 Bean生命周期配置</h4><ul><li><strong>init-method</strong>：指定类中的初始化方法名称。</li><li><strong>destroy-method</strong>：指定类中销毁方法名称。<br></li></ul><h4 id="3-4-Bean实例化三种方式"><a href="#3-4-Bean实例化三种方式" class="headerlink" title="3.4 Bean实例化三种方式"></a>3.4 Bean实例化三种方式</h4><ul><li><p><strong>无参构造</strong>方法实例化。</p></li><li><p><strong>工厂静态</strong>方法实例化。</p></li><li><p><strong>工厂实例</strong>方法实例化 。</p></li><li><p>使用无参构造方法实例化，它会根据默认无参构造方法来创建类对象，如果bean中没有默认无参构造函数，将会创建失败。</p></li></ul><p><img src="/2022/05/17/Spring1/10.jpeg"><br><br></p><ul><li>工厂静态方法实例化：工厂的静态方法返回Bean实例。</li></ul><p><img src="/2022/05/17/Spring1/12.jpeg"><br><br></p><ul><li>工厂实例方法实例化：工厂的非静态方法返回Bean实例。</li></ul><p><img src="/2022/05/17/Spring1/14.jpeg"><br><br></p><h4 id="3-5-Bean的依赖注入入门"><a href="#3-5-Bean的依赖注入入门" class="headerlink" title="3.5 Bean的依赖注入入门"></a>3.5 Bean的依赖注入入门</h4><ul><li>创建UserServiceImpl，UserServiceImpl内部在调用UserDao的save()方法。</li></ul><p><img src="/2022/05/17/Spring1/15.jpeg"><br><br></p><ul><li>将UserServiceImpl的创建权交给Spring。</li></ul><p><img src="/2022/05/17/Spring1/16.jpeg"><br><br></p><ul><li>从Spring容器中获得UserService进行操作。</li></ul><p><img src="/2022/05/17/Spring1/17.jpeg"><br><br></p><h4 id="3-6-Bean的依赖注入分析"><a href="#3-6-Bean的依赖注入分析" class="headerlink" title="3.6 Bean的依赖注入分析"></a>3.6 Bean的依赖注入分析</h4><ul><li>目前UserService实例和UserDao实例都存在与Spring容器中，当前的做法是在容器外部获得UserService实例和UserDao实例，然后在程序中进行结合。</li></ul><p><img src="/2022/05/17/Spring1/18.jpeg"><br><br></p><ul><li>因为UserService和UserDao都在Spring容器中，而最终程序直接使用的是UserService，所以可以在Spring容器中，将UserDao设置到UserService内部。</li></ul><p><img src="/2022/05/17/Spring1/19.jpeg"><br><br></p><h4 id="3-7-Bean的依赖注入概念"><a href="#3-7-Bean的依赖注入概念" class="headerlink" title="3.7 Bean的依赖注入概念"></a>3.7 Bean的依赖注入概念</h4><ul><li><p><strong>依赖注入</strong>：<strong>它是Spring框架核心IOC的具体实现</strong>。</p></li><li><p>在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p></li><li><p>那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。</p></li><li><p>简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></li><li><p>Bean的注入依赖方式：</p><ul><li>构造方法。</li><li>set方法。</li></ul></li><li><p>set方法：配置Spring容器调用set方法进行注入。</p></li></ul><p><img src="/2022/05/17/Spring1/20.jpeg"><br><br></p><ul><li>P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下：首先，需要引入P命名空间，其次，需要修改注入方式。</li></ul><p><img src="/2022/05/17/Spring1/21.jpeg"><br><br></p><ul><li><p>构造方法注入：创建有参构造。</p></li><li><p>配置Spring容器调用有参构造时进行注入。</p></li></ul><p><img src="/2022/05/17/Spring1/22.jpeg"><br><br></p><h4 id="3-8-Bean的依赖注入的数据类型"><a href="#3-8-Bean的依赖注入的数据类型" class="headerlink" title="3.8 Bean的依赖注入的数据类型"></a>3.8 Bean的依赖注入的数据类型</h4><ul><li><p>上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p></li><li><p>注入数据的三种数据类型：</p><ul><li>普通数据类型。</li><li>引用数据类型。</li><li>集合数据类型。</li></ul></li><li><p>下面将以set方法注入为例，演示普通数据类型和集合数据类型的注入。</p></li><li><p>普通数据类型的注入。</p></li></ul><p><img src="/2022/05/17/Spring1/23.jpeg"><br><br></p><ul><li>集合数据类型(<strong>List&lt; String &gt;</strong>)的注入。</li></ul><p><img src="/2022/05/17/Spring1/24.jpeg"><br><img src="/2022/05/17/Spring1/25.jpeg"><br><br></p><ul><li>集合数据类型(<strong>List&lt; User &gt;</strong>)的注入。</li></ul><p><img src="/2022/05/17/Spring1/26.jpeg"><br><img src="/2022/05/17/Spring1/27.jpeg"><br><br></p><ul><li>集合数据类型(Properties)的注入。</li></ul><p><img src="/2022/05/17/Spring1/28.jpeg"><br><img src="/2022/05/17/Spring1/29.jpeg"><br><br></p><h4 id="3-9-引入其他配置文件-分模块开发"><a href="#3-9-引入其他配置文件-分模块开发" class="headerlink" title="3.9 引入其他配置文件(分模块开发)"></a>3.9 引入其他配置文件(分模块开发)</h4><ul><li><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载。</p><p>  <img src="/2022/05/17/Spring1/30.jpeg"></p></li></ul><p><img src="/2022/05/17/Spring1/31.jpeg"></p><h2 id="四、Spring相关API"><a href="#四、Spring相关API" class="headerlink" title="四、Spring相关API"></a>四、Spring相关API</h2><h4 id="4-1-ApplicationContext的继承关系"><a href="#4-1-ApplicationContext的继承关系" class="headerlink" title="4.1 ApplicationContext的继承关系"></a>4.1 ApplicationContext的继承关系</h4><ul><li><p>applicationContext：接口类型，代表应用上下文，可以通过其实例获得 Spring容器中的Bean对象。</p><p>  <img src="/2022/05/17/Spring1/32.jpeg"></p></li></ul><h4 id="4-2-ApplicationContext的实现类"><a href="#4-2-ApplicationContext的实现类" class="headerlink" title="4.2 ApplicationContext的实现类"></a>4.2 ApplicationContext的实现类</h4><p><img src="/2022/05/17/Spring1/33.jpeg"> </p><h4 id="4-3-getBean-方法的使用"><a href="#4-3-getBean-方法的使用" class="headerlink" title="4.3 getBean()方法的使用"></a>4.3 getBean()方法的使用</h4><p><img src="/2022/05/17/Spring1/34.jpeg"></p><ul><li>其中，当参数的数据类型是字符串时，表示根据Bean的id从容器中获得Bean实例，返回是Object，需要强转。当参数的数据类型是Class类型时，表示根据类型从容器中匹配Bean实例，当容器中相同类型的Bean有多个时，则此方法会报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/04/17/Git/"/>
      <url>/2022/04/17/Git/</url>
      
        <content type="html"><![CDATA[<br><ul><li>文章开始之前先给大家推荐一个很好的在线学习网站<ul><li>推荐给大家: <a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></li></ul></li></ul><p><img src="/2022/04/17/Git/1.png">        </p><h3 id="Git操作流程"><a href="#Git操作流程" class="headerlink" title="Git操作流程"></a>Git操作流程</h3><h4 id="代码提交和同步代码"><a href="#代码提交和同步代码" class="headerlink" title="代码提交和同步代码"></a>代码提交和同步代码</h4><p><img src="/2022/04/17/Git/2.png"><br><br></p><h4 id="代码撤销和撤销同步"><a href="#代码撤销和撤销同步" class="headerlink" title="代码撤销和撤销同步"></a>代码撤销和撤销同步</h4><p><img src="/2022/04/17/Git/3.png"><br><br></p><h3 id="Git常用操作命令-代码提交和同步代码"><a href="#Git常用操作命令-代码提交和同步代码" class="headerlink" title="Git常用操作命令 - 代码提交和同步代码"></a>Git常用操作命令 - 代码提交和同步代码</h3><ul><li>第零步: 工作区与仓库保持一致</li><li>第一步: 文件增删改，变为已修改状态</li><li>第二步: git add ，变为已暂存状态</li></ul><!-- <html><style>    .mac {        width:10px;        height:10px;        border-radius:5px;        float:left;        margin:10px 0 0 5px;    }    .b1 {        background:#E0443E;        margin-left: 10px;    }    .b2 { background:#DEA123; }    .b3 { background:#1AAB29; }    .warpper{        background:#121212;        border-radius:5px 5px 0 0;        width:600px;        height:30px;        color:#0f0;        line-height:30px;    }</style><div class="warpper">    <div class="mac b1"></div>    <div class="mac b2"></div>    <div class="mac b3"></div><div><br></html> --><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add --all <span class="comment"># 当前项目下的所有更改</span></span><br><span class="line">$ git add .  <span class="comment"># 当前目录下的所有更改</span></span><br><span class="line">$ git add xx/xx.py xx/xx2.py  <span class="comment"># 添加某几个文件</span></span><br></pre></td></tr></table></figure><ul><li><p>第三步: git commit，变为已提交状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m<span class="string">&quot;&lt;这里写commit的描述&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>第四步: git push，变为已推送状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master <span class="comment"># 第一次需要关联上</span></span><br><span class="line">$ git push <span class="comment"># 之后再推送就不用指明应该推送的远程分支了</span></span><br><span class="line">$ git branch <span class="comment"># 可以查看本地仓库的分支</span></span><br><span class="line">$ git branch -a <span class="comment"># 可以查看本地仓库和本地远程仓库(远程仓库的本地镜像)的所有分支</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>在某个分支下，我最常用的操作如下</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git add -a</span><br><span class="line">$ git status</span><br><span class="line">$ git commit -m <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">$ git pull --rebase</span><br><span class="line">$ git push origin xxbranch</span><br></pre></td></tr></table></figure><br><h3 id="Git常用操作命令-代码撤销和撤销同步"><a href="#Git常用操作命令-代码撤销和撤销同步" class="headerlink" title="Git常用操作命令 - 代码撤销和撤销同步"></a>Git常用操作命令 - 代码撤销和撤销同步</h3><p><strong>已修改，但未暂存</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git diff <span class="comment"># 列出所有的修改</span></span><br><span class="line">$ git diff xx/xx.py xx/xx2.py <span class="comment"># 列出某(几)个文件的修改</span></span><br><span class="line"></span><br><span class="line">$ git checkout <span class="comment"># 撤销项目下所有的修改</span></span><br><span class="line">$ git checkout . <span class="comment"># 撤销当前文件夹下所有的修改</span></span><br><span class="line">$ git checkout xx/xx.py xx/xx2.py <span class="comment"># 撤销某几个文件的修改</span></span><br><span class="line">$ git clean -f <span class="comment"># untracked状态，撤销新增的文件</span></span><br><span class="line">$ git clean -<span class="built_in">df</span> <span class="comment"># untracked状态，撤销新增的文件和文件夹</span></span><br></pre></td></tr></table></figure><br><p><strong>已暂存，未提交</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached <span class="comment"># 这个命令显示暂存区和本地仓库的差异</span></span><br><span class="line"></span><br><span class="line">$ git reset <span class="comment"># 暂存区的修改恢复到工作区</span></span><br><span class="line">$ git reset --soft <span class="comment"># 与git reset等价，回到已修改状态，修改的内容仍然在工作区中</span></span><br><span class="line">$ git reset --hard <span class="comment"># 回到未修改状态，清空暂存区和工作区</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>git reset –hard 操作等价于 git reset 和 git checkout 2步操作</p></blockquote><br><p><strong>已提交，未推送</strong></p><blockquote><p>执行完commit之后，会在仓库中生成一个版本号(hash值)，标志这次提交。之后任何时候，都可以借助这个hash值回退到这次提交。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &lt;branch-name1&gt; &lt;branch-name2&gt; <span class="comment"># 比较2个分支之间的差异</span></span><br><span class="line">$ git diff master origin/master <span class="comment"># 查看本地仓库与本地远程仓库的差异</span></span><br><span class="line"></span><br><span class="line">$ git reset --hard origin/master <span class="comment"># 回退与本地远程仓库一致</span></span><br><span class="line">$ git reset --hard HEAD^ <span class="comment"># 回退到本地仓库上一个版本</span></span><br><span class="line">$ git reset --hard &lt;<span class="built_in">hash</span> code&gt; <span class="comment"># 回退到任意版本</span></span><br><span class="line">$ git reset --soft/git reset <span class="comment"># 回退且回到已修改状态，修改仍保留在工作区中。</span></span><br></pre></td></tr></table></figure><br><p><strong>已推送到远程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push -f orgin master # 强制覆盖远程分支</span><br><span class="line">$ git push -f # 如果之前已经用 -u 关联过，则可省略分支名</span><br></pre></td></tr></table></figure><blockquote><p>慎用，一般情况下，本地分支比远程要新，所以可以直接推送到远程，但有时推送到远程后发现有问题，进行了版本回退，旧版本或者分叉版本推送到远程，需要添加 -f参数，表示强制覆盖。</p></blockquote><br><h3 id="Git常用操作命令-其它常用命令"><a href="#Git常用操作命令-其它常用命令" class="headerlink" title="Git常用操作命令 - 其它常用命令"></a>Git常用操作命令 - 其它常用命令</h3><p><strong>关联远程仓库</strong></p><ul><li><p>如果还没有Git仓库，你需要</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>如果你想关联远程仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;name&gt; &lt;git-repo-url&gt;</span><br><span class="line"><span class="comment"># 例如 git remote add origin https://github.com/xxxxxx # 是远程仓库的名称，通常为 origin</span></span><br></pre></td></tr></table></figure></li><li><p>如果你想关联多个远程仓库 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &lt;name&gt; &lt;another-git-repo-url&gt;</span><br><span class="line"><span class="comment"># 例如 git remote add coding https://coding.net/xxxxxx</span></span><br></pre></td></tr></table></figure></li><li><p>忘了关联了哪些仓库或者地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># origin https://github.com/gzdaijie/koa-react-server-render-blog.git (fetch)</span></span><br><span class="line"><span class="comment"># origin https://github.com/gzdaijie/koa-react-server-render-blog.git (push)</span></span><br></pre></td></tr></table></figure></li><li><p>如果远程有仓库，你需要clone到本地</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;git-repo-url&gt;</span><br><span class="line"><span class="comment"># 关联的远程仓库将被命名为origin，这是默认的。</span></span><br></pre></td></tr></table></figure></li><li><p>如果你想把别人仓库的地址改为自己的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin &lt;your-git-url&gt;</span><br></pre></td></tr></table></figure><br></li></ul><p><strong>切换分支</strong></p><blockquote><p>新建仓库后，默认生成了master分支</p></blockquote><ul><li><p>如果你想新建分支并切换</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;new-branch-name&gt;</span><br><span class="line"><span class="comment"># 例如 git checkout -b dev</span></span><br><span class="line"><span class="comment"># 如果仅新建，不切换，则去掉参数 -b</span></span><br></pre></td></tr></table></figure></li><li><p>看看当前有哪些分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line"><span class="comment"># * dev</span></span><br><span class="line"><span class="comment">#   master # 标*号的代表当前所在的分支</span></span><br></pre></td></tr></table></figure></li><li><p>看看当前本地&amp;远程有哪些分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br><span class="line"><span class="comment"># * dev</span></span><br><span class="line"><span class="comment">#   master</span></span><br><span class="line"><span class="comment">#   remotes/origin/master</span></span><br></pre></td></tr></table></figure></li><li><p>切换到现有的分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure></li><li><p>你想把dev分支合并到master分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branch-name&gt;</span><br><span class="line"><span class="comment"># 例如 git merge dev</span></span><br></pre></td></tr></table></figure></li><li><p>你想把本地master分支推送到远程去</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line"><span class="comment"># 你可以使用git push -u origin master将本地分支与远程分支关联，之后仅需要使用git push即可。</span></span><br></pre></td></tr></table></figure></li><li><p>远程分支被别人更新了，你需要更新代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin &lt;branch-name&gt;</span><br><span class="line"><span class="comment"># 之前如果push时使用过-u，那么就可以省略为git pull</span></span><br></pre></td></tr></table></figure></li><li><p>本地有修改，能不能先git pull</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="comment"># 工作区修改暂存</span></span><br><span class="line">$ git pull  <span class="comment"># 更新分支</span></span><br><span class="line">$ git stash pop <span class="comment"># 暂存修改恢复到工作区</span></span><br></pre></td></tr></table></figure><br></li></ul><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul><li><p>恢复暂存区文件到工作区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;file-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>恢复暂存区的所有文件到工作区</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout .</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区的某文件，与上一次commit保持一致，但工作区不变</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &lt;file-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>重置暂存区与工作区，与上一次commit保持一致</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;file-name&gt;</span><br><span class="line"><span class="comment"># 如果是回退版本(commit)，那么file，变成commit的hash码就好了。</span></span><br></pre></td></tr></table></figure></li><li><p>去掉某个commit</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git revert &lt;commit-hash&gt;</span><br><span class="line"><span class="comment"># 实质是新建了一个与原来完全相反的commit，抵消了原来commit的效果</span></span><br></pre></td></tr></table></figure></li><li><p>reset回退错误恢复</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog <span class="comment">#查看最近操作记录</span></span><br><span class="line">$ git reset --hard HEAD&#123;5&#125; <span class="comment">#恢复到前五笔操作</span></span><br><span class="line">$ git pull origin backend-log <span class="comment">#再次拉取代码</span></span><br></pre></td></tr></table></figure><br></li></ul><h3 id="版本回退与前进"><a href="#版本回退与前进" class="headerlink" title="版本回退与前进"></a>版本回退与前进</h3><ul><li><p>查看历史版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li><li><p>你可能觉得这样的log不好看，试试这个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --decorate --abbrev-commit --all</span><br></pre></td></tr></table></figure></li><li><p>检出到任意版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout a5d88ea</span><br><span class="line"><span class="comment"># hash码很长，通常6-7位就够了</span></span><br></pre></td></tr></table></figure></li><li><p>远程仓库的版本很新，但是你还是想用老版本覆盖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master --force</span><br><span class="line"><span class="comment"># 或者 git push -f origin master</span></span><br></pre></td></tr></table></figure></li><li><p>觉得commit太多了? 多个commit合并为1个</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i HEAD~4</span><br><span class="line"><span class="comment"># 这个命令，将最近4个commit合并为1个，HEAD代表当前版本。将进入VIM界面，你可以修改提交信息。推送到远程分支的commit，不建议这样做，多人合作时，通常不建议修改历史。</span></span><br></pre></td></tr></table></figure></li><li><p>想回退到某一个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &lt;<span class="built_in">hash</span>&gt;</span><br><span class="line"><span class="comment"># 例如 git reset --hard a3hd73r</span></span><br><span class="line"><span class="comment"># --hard代表丢弃工作区的修改，让工作区与版本代码一模一样，与之对应，--soft参数代表保留工作区的修改。</span></span><br></pre></td></tr></table></figure></li><li><p>想回退到上一个版本，有没有简便方法?</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>回退到上上个版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^^</span><br><span class="line"><span class="comment"># HEAD^^可以换作具体版本hash值。</span></span><br></pre></td></tr></table></figure></li><li><p>回退错了，能不能前进</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line"><span class="comment"># 这个命令保留了最近执行的操作及所处的版本，每条命令前的hash值，则是对应版本的hash值。使用上述的git checkout 或者 git reset命令 则可以检出或回退到对应版本。</span></span><br></pre></td></tr></table></figure></li><li><p>刚才commit信息写错了，可以修改吗</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>看看当前状态吧</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><br></li></ul><h3 id="配置属于你的Git"><a href="#配置属于你的Git" class="headerlink" title="配置属于你的Git"></a>配置属于你的Git</h3><ul><li><p>看看当前的配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></li><li><p>估计你需要配置你的名字</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;&lt;name&gt;&quot;</span></span><br><span class="line"><span class="comment">#  --global为可选参数，该参数表示配置全局信息</span></span><br></pre></td></tr></table></figure></li><li><p>希望别人看到你的commit可以联系到你</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;&lt;email address&gt;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>有些命令很长，能不能简化一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.logg <span class="string">&quot;log --graph --decorate --abbrev-commit --all&quot;</span></span><br><span class="line"><span class="comment"># 之后就可以开心地使用 git log了</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用工具 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
